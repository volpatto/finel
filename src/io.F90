      !> Contains input/output variables and routines.
      !! @author    Diego T. Volpatto
      module mIO

            implicit none

            integer, parameter  :: iin = 1110 !< Input file id
            integer, parameter  :: iout = 1120 !< Output file id
            integer, parameter  :: isol = 1130 !< Solution file id
            integer, parameter  :: ioutn = 1140 !< Node output file
            integer, parameter  :: ioute = 1150 !< Element output file 
            integer, parameter  :: isolcsv = 1160 !< Solution csv file id
            integer, parameter  :: isolvtk = 1170 !< Solution vtk file id

            !> Input file name
            character(len=20), parameter :: inFile='input.dat'
            !> Output file name
            character(len=20), parameter :: outFile='output.dat'
            !> Output node's file name
            character(len=20), parameter :: outNodes='outnodes.dat'
            !> Output elements' file name
            character(len=20), parameter :: outElem='outelem.dat'
            !> Solution file name
            character(len=50), parameter :: solFile='solution00'

            character(len=50) :: title, file_format

            contains

            !> Open IO files.
            !! @author Diego T. Volpatto
            subroutine openFiles()

                implicit none

                open(unit=iin,file=inFile)
                open(unit=iout,file=outFile)
                !open(unit=isol,file=solFile)
                open(unit=ioutn,file=outNodes)
                open(unit=ioute,file=outElem)

            endsubroutine

            !> Close IO files.
            !! @author Diego T. Volpatto
            subroutine closeFiles()

                implicit none

                close(iin)
                close(iout)
                !close(isol)
                close(ioutn)
                close(ioute)

            endsubroutine

            !> Subroutine to read node data file generated by EasyMesh.
            !! @param mesh_     [in/out] a mesh structure
            !! @author  Diego Volpatto
            subroutine read_nodes(mesh_)

                use meshStructure
            
                implicit none
                
                type(mesh)          :: mesh_
                integer             :: i, dummy_nsd, dummy_atb, dummy_bdmrk
                character*8         :: node

                if (mesh_%meshgen .eq. "easymesh") then
                open(unit=100, file=trim(mesh_%filename)//'.n')
                read(100,*) mesh_%nnodes
                else if (mesh_%meshgen .eq. "triangle") then
                open(unit=100, file=trim(mesh_%filename)//'.node')
                read(100,*) mesh_%nnodes, dummy_nsd, dummy_atb, dummy_bdmrk
                endif
                !print*, mesh_%nnodes

                call mallocNodes(mesh_)

                do i=1,mesh_%nnodes
                    read(100,*) node, mesh_%x(1,i), mesh_%x(2,i), mesh_%flagnode(i)
                    write(ioutn,*) i, mesh_%x(1,i), mesh_%x(2,i), mesh_%flagnode(i)
                enddo

                close(100)

            endsubroutine

            !> Subroutine to read element data file generated by EasyMesh.
            !! @param mesh_     [in/out] a mesh structure
            !! @author  Diego Volpatto
            subroutine read_elems(mesh_)

                use meshStructure
            
                implicit none
                
                type(mesh)          :: mesh_
                integer             :: i, dummy_nen, dummy_atb, j
                character*8         :: elem

                if (mesh_%meshgen .eq. "easymesh") then
                open(unit=100, file=trim(mesh_%filename)//'.e')
                read(100,*) mesh_%nelems
                else if (mesh_%meshgen .eq. "triangle") then
                open(unit=100, file=trim(mesh_%filename)//'.ele')
                read(100,*) mesh_%nelems, dummy_nen, dummy_atb
                if (dummy_nen .ne. mesh_%nen) then
                    write(iout,*) "Unmatched number of nen (mesh)"
                    write(*,*) "Unmatched number of nen (mesh)"
                    stop
                endif
                endif
                !print*, mesh_%nelems

                call mallocElem(mesh_)

                if (mesh_%meshgen .eq. "easymesh") then
                do i=1,mesh_%nelems
                    if (mesh_%nen.eq.3) then
                    read(100,*) elem, & 
                        mesh_%gnode(i,1), mesh_%gnode(i,2), mesh_%gnode(i,3), &
                        mesh_%ei(i), mesh_%ej(i), mesh_%ek(i), & 
                        mesh_%si(i), mesh_%sj(i), mesh_%sk(i), &
                        mesh_%xV(i), mesh_%yV(i), mesh_%mat(i)
                    write(ioute,*) i, & 
                        mesh_%gnode(i,1), mesh_%gnode(i,2), mesh_%gnode(i,3), &
                    mesh_%xV(i), mesh_%yV(i), mesh_%mat(i)
                    endif
                    if (mesh_%nen.eq.4) then
                    read(100,*) elem, & 
                        mesh_%gnode(i,1), mesh_%gnode(i,2), mesh_%gnode(i,3), mesh_%gnode(i,4), &
                        mesh_%ei(i), mesh_%ej(i), mesh_%ek(i), & 
                        mesh_%si(i), mesh_%sj(i), mesh_%sk(i), &
                        mesh_%xV(i), mesh_%yV(i), mesh_%mat(i)
                    write(ioute,*) i, & 
                        mesh_%gnode(i,1), mesh_%gnode(i,2), mesh_%gnode(i,3), mesh_%gnode(i,4), &
                    mesh_%xV(i), mesh_%yV(i), mesh_%mat(i)
                    endif
                enddo

                else if (mesh_%meshgen .eq. "triangle") then
                do i=1,mesh_%nelems
                    read(100,*) elem, & 
                        (mesh_%gnode(i,j), j=1,dummy_nen)!, &
                        mesh_%ei(i)=-1; mesh_%ej(i)=-1; mesh_%ek(i)=-1
                        mesh_%si(i)=-1; mesh_%sj(i)=-1; mesh_%sk(i)=-1
                        mesh_%xV(i)=-1; mesh_%yV(i)=-1; mesh_%mat(i)=-1
                    write(ioute,*) i, & 
                        (mesh_%gnode(i,j), j=1,dummy_nen) 
                enddo
                endif

                close(100)

            endsubroutine

            !> Prints the solution of scalar field.
            !! @param mesh_     A mesh structure
            !! @param scalar_   A scalar structure
            !! @param tstep     Time step index
            !! @author  Diego T. Volpatto
            subroutine print_sol(mesh_, scalar_, tstep)

                use meshStructure
                use scalarStructure

                implicit none

                type(mesh) :: mesh_
                type(scalarStructureSystem) :: scalar_
                integer :: tstep

                integer :: i, j
                character(len=50) :: solFileDAT, tempstr

                write(tempstr,'(i0)') tstep
                solFileDAT = trim(solFile)//trim(tempstr)//".dat"
                open(unit=isol,file=solFileDAT)

                do i=1,mesh_%nnodes
                !write(isol,*) i, mesh_%x(1,i), scalar_%u(i)
                write(isol,*) i, (mesh_%x(j,i), j=1,mesh_%nsd), scalar_%u(i)
                enddo

                close(isol)

            endsubroutine

            !> Prints gradient 1D.
            !! @param mesh_     A mesh structure
            !! @param scalar_   A scalar structure
            !! @param tstep     Time step index
            !! @author  Diego T. Volpatto
            subroutine print_grad(mesh_, scalar_, tstep)

                use meshStructure
                use scalarStructure

                implicit none

                type(mesh) :: mesh_
                type(scalarStructureSystem) :: scalar_
                integer :: tstep

                integer :: i, j
                character(len=50) :: gradFileDAT, tempstr

                write(tempstr,'(i0)') tstep
                gradFileDAT = "grad00"//trim(tempstr)//".dat"
                open(unit=25,file=gradFileDAT)

                do i=1,mesh_%nnodes
                !write(isol,*) i, mesh_%x(1,i), scalar_%u(i)
                write(25,*) i, (mesh_%x(j,i), j=1,mesh_%nsd),scalar_%grad(i)
                enddo

                close(25)

            endsubroutine

            !> Prints the solution of scalar field in the csv format
            !! aiming to compatibility with Paraview post-processing.
            !! @param mesh_     A mesh structure
            !! @param scalar_   A scalar structure
            !! @param tstep     Time step index
            !! @author  Diego T. Volpatto
            subroutine print_sol_csv(mesh_, scalar_, tstep)

                use meshStructure
                use scalarStructure

                implicit none

                type(mesh) :: mesh_
                type(scalarStructureSystem) :: scalar_
                integer :: tstep

                integer :: i, j
                character(len=50) :: xx, yy, zz, scalarField
                character(len=50) :: solFileCSV, tempstr
                character(len=5) :: ii

                write(tempstr,'(i0)') tstep
                solFileCSV = trim(solFile)//trim(tempstr)//".csv"
                open(unit=isolcsv,file=solFileCSV)

                write(isolcsv,*) "xcoord, ycoord, zcoord, scalar"
                do i=1,mesh_%nnodes
                !write(ii,'(i0)') i
                !ii = trim(ii)//', '
                write(xx,'(f0.20)') mesh_%x(1,i)
                xx = trim(xx)//', '
                if (mesh_%nsd .gt. 1) then
                    write(yy,'(f0.20)') mesh_%x(2,i)
                    yy = trim(yy)//', '
                    write(zz,'(f0.20)') 0.0
                    zz = trim(zz)//', '
                else
                    write(yy,'(f0.20)') 0.0
                    yy = trim(yy)//', '
                    write(zz,'(f0.20)') 0.0
                    zz = trim(zz)//', '
                endif
                write(scalarField,'(f0.20)') scalar_%u(i)
                scalarField = trim(scalarField)
                !write(isol,*) i, mesh_%x(1,i), scalar_%u(i)
                !write(isolprv,*) i, (mesh_%x(j,i), j=1,mesh_%nsd), scalar_%u(i)
                write(isolcsv,*) xx, yy, zz, scalarField
                !stop
                enddo

                close(isolcsv)

            endsubroutine

            !> Prints the solution of scalar field in the vtk "legacy" format
            !! aiming to compatibility with Paraview post-processing.
            !! @param mesh_     A mesh structure
            !! @param scalar_   A scalar structure
            !! @param tstep     Current time step
            !! @author  Diego T. Volpatto
            subroutine print_sol_vtk(mesh_, scalar_, tstep)

                use meshStructure
                use scalarStructure

                implicit none

                type(mesh) :: mesh_
                type(scalarStructureSystem) :: scalar_
                integer :: tstep

                integer :: i, j
                character(len=50) :: xx, yy, zz, scalarField, tempstr
                character(len=50) :: tempstr2, solFileVTK
                character(len=5) :: ii
                integer :: inodes(mesh_%nen)

                write(tempstr,'(i0)') tstep
                solFileVTK = trim(solFile)//trim(tempstr)//".vtk"
                open(unit=isolvtk,file=solFileVTK)

                write(isolvtk,'(a)') "# vtk DataFile Version 3.0"
                write(isolvtk,'(a)') "2D scalar data"
                write(isolvtk,'(a)') "ASCII"
                write(isolvtk,*) 
                write(isolvtk,'(a)') "DATASET UNSTRUCTURED_GRID" 
                write(tempstr,'(i0)') mesh_%nnodes
                write(isolvtk,'(a)') "POINTS "//trim(tempstr)//" float" 
                do i=1,mesh_%nnodes
                if (mesh_%nsd .gt. 1) then
                    write(isolvtk,2000) (mesh_%x(j,i),j=1,mesh_%nsd), 0.0
                else
                    write(isolvtk,2000) mesh_%x(1,i), 0.0, 0.0
                endif
                enddo
                write(isolvtk,*) 
                write(tempstr,'(i0)') mesh_%nelems
                write(tempstr2,'(i0)') (mesh_%nen+1)*mesh_%nelems
                write(isolvtk,'(a)') "CELLS "//trim(tempstr)//" "//trim(tempstr2)
                do i=1,mesh_%nelems
                inodes=mesh_%gnode(i,:); !print*, inodes;
                if (mesh_%meshgen .eq. "triangle") inodes=inodes-1
                if (mesh_%nen.eq.3) write(isolvtk,1000) mesh_%nen, (inodes(j),j=1,mesh_%nen)
                if (mesh_%nen.eq.4) write(isolvtk,4000) mesh_%nen, (inodes(j),j=1,mesh_%nen)
                enddo
                write(isolvtk,*) 
                write(tempstr,'(i0)') mesh_%nelems
                write(isolvtk,'(a)') "CELL_TYPES "//trim(tempstr)
                do i=1,mesh_%nelems
                if(mesh_%nen.eq.3) write(isolvtk,'(i0)') 5 
                if(mesh_%nen.eq.4) write(isolvtk,'(i0)') 9 
                enddo
                write(isolvtk,*) 
                write(tempstr,'(i0)') mesh_%nnodes
                write(isolvtk,'(a)') "POINT_DATA "//trim(tempstr)
                !write(isolvtk,*) "SCALARS scalarField  float 1"
                write(isolvtk,'(a)') "FIELD FieldData 1"
                write(isolvtk,'(a)') "nodal 1 "//trim(tempstr)//" float"
                !write(isolvtk,'(a)') "LOOKUP_TABLE default"
                do i=1,mesh_%nnodes
                write(isolvtk,3000) scalar_%u(i)
                enddo
                close(isolvtk)
1000            format(4(i0,1x))
4000            format(5(i0,1x))
2000            format(3(f13.10,1x))
3000            format(1(f12.10))

            endsubroutine

            !> Record solution according to specified file kind in
            !! input.
            !! @param mesh_     A mesh structure
            !! @param scalar_   A scalar structure
            !! @param tstep     Time step to print
            !! @author Diego T. Volpatto
            subroutine print_files(mesh_, scalar_, tstep)

                use meshStructure
                use scalarStructure

                implicit none

                type(mesh) :: mesh_
                type(scalarStructureSystem) :: scalar_
                integer :: tstep

                if (file_format .eq. ".dat") call print_sol(mesh_,scalar_,tstep)
                if (file_format .eq. ".csv") call print_sol_csv(mesh_,scalar_,tstep)
                if (file_format .eq. ".vtk") call print_sol_vtk(mesh_,scalar_,tstep)

            endsubroutine
        endmodule
